#!/usr/bin/python

# =============================================================================
#
#    gnome-gocryptfs - GNOME keyring and auto-mount integration of gocryptfs folders.
#    Copyright (c) 2020 Colin Jermain <cjermain@gmail.com>
#                  2010 Oben Sonne <obensonne@googlemail.com>
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# =============================================================================

import getpass
import os
import os.path
import optparse
import subprocess
import sys
from collections import defaultdict

from xdg.DesktopEntry import DesktopEntry as xdg_de
from xdg.BaseDirectory import xdg_config_home as xdg_ch

import gi
gi.require_version('Secret', '1')
from gi.repository import Secret

# =============================================================================
# test mode related
# =============================================================================

TEST = "GNOME_GOCRYPTFS_TEST" in os.environ

class preset:
    """Preset user input. Used for non-interactive testing mode."""

    proceed = None
    password = None
    epath = None
    econfig = None
    mpoint = None
    amount = None

# =============================================================================

class KeyRing(object):
    """The KeyRing object wraps the gi.repository.Secret library provided by
    libsecret for GNOME. It uses a specific schema for the purpose of storing
    keys for gnome-gocrpytfs, and provides convenience methods for adding,
    editing, finding, and removing these keys in the keyring.
    """

    COLLECTION = Secret.COLLECTION_DEFAULT

    SCHEMA = Secret.Schema.new(
        "gnome-gocryptfs.Store",
        Secret.SchemaFlags.NONE,
        {
            "gnome-gocryptfs": Secret.SchemaAttributeType.STRING,
            "gocryptfs-config": Secret.SchemaAttributeType.STRING,
            "gocryptfs-path": Secret.SchemaAttributeType.STRING,
            "mount-point": Secret.SchemaAttributeType.STRING,
            "auto-mount": Secret.SchemaAttributeType.STRING,
        }
    )

    def __init__(self):
        """Constructs a KeyRing object which handles setting, editing, and removing
        an item from the keyring. This holds a Service and Collection object with
        libsecret.
        """
        self.service = Secret.Service.get_sync(Secret.ServiceFlags.LOAD_COLLECTIONS)
        self.collection = Secret.Collection.for_alias_sync(
            self.service,
            self.COLLECTION,
            Secret.CollectionFlags.LOAD_ITEMS,
        )

    def default_attributes(self):
        """Returns a dictionary with default attributes that conforms to the
        schema.
        """
        return {
            # TODO: Remove this test patch
            "gnome-gocryptfs": "TEST" if TEST else "",
            "gocryptfs-config": "-",
            "gocryptfs-path": "",
            "mount-point": "",
            "auto-mount": "n",
        }

    def add(self, label, attributes, secret):
        """Adds an item to the keyring.

        :param label: String name of the key
        :param attributes: Dictionary of non-secret lookup information
        :param secret: String secret key
        """
        Secret.password_store_sync(self.SCHEMA, attributes, self.COLLECTION, label, secret)

    def edit(self, item, attributes=None, secret=None):
        """Edit an existing item with new attributes or secret if provided.
        Only attributes that are provided will be changed.

        :param item: Secret.Item object
        :param attributes: Dictionary of non-secret lookup information
        :param secret: String secret key
        """
        if attributes is not None:
            # Update the current values
            current_attributes = item.get_attributes()
            current_attributes.update(attributes)
            item.set_attributes_sync(self.SCHEMA, current_attributes)
        if secret is not None:
            # Update the password
            secret_value = Secret.Value.new(secret, len(secret), "text/plain")
            item.set_secret_sync(secret_value)

    def remove(self, item):
        """Removes an existing item from the keyring.

        :param item: Secret.Item object
        """
        item.delete_sync()

    def find(self, attributes=None):
        """Returns a list of items in the keyring that match the attributes.

        :param attributes: Dictionary of non-secret lookup information
        """
        if attributes is None:
            attributes = {}

        # TODO: Remove this test patch
        attributes["gnome-gocryptfs"] = "TEST" if TEST else ""
        items = self.collection.search_sync(
            self.SCHEMA,
            attributes,
            Secret.SearchFlags.LOAD_SECRETS | Secret.SearchFlags.ALL
        )

        return sorted(items, key=lambda x: x.get_attributes()["mount-point"])

    def find_keys_for_path(self, path, attributes=None):
        """Returns a list of items in the keyring that match either the
        mount-point or gocryptfs-path.

        :param path: String path
        :param attributes: Additional attributes to consider
        """
        if attributes is None:
            attributes = {}

        # TODO: Remove this test patch
        attributes["gnome-gocryptfs"] = "TEST" if TEST else ""

        search_attributes = attributes.copy()
        search_attributes["gocryptfs-path"] = path

        items = self.find(search_attributes)

        search_attributes = attributes.copy()
        search_attributes["mount-point"] = path

        items.extend(self.find(search_attributes))

        return sorted(items, key=lambda x: x.get_attributes()["mount-point"])


# Provide access to the default GNOME keyring
KEYRING = KeyRing()

MSG_NO_MATCH = ("No matching gocryptfs items in keyring.\n"
                "Use option --list to show available items or "
                "option --add to add items.")

MSG_NO_GOCRYPTFS_PATH = ("no gocryptfs at given path (or the gocryptfs config file "
                     "location is invalid)")

USAGE = """Usage: %prog --list
       %prog --mount [GOCRYPTFS-PATH-or-MOUNT-POINT]
       %prog --add GOCRYPTFS-PATH MOUNT-POINT
       %prog --edit MOUNT-POINT
       %prog --remove MOUNT-POINT"""

DESCRIPTION = """Painlessly mount and manage gocryptfs folders using GNOME's
keyring."""

EPILOG = """This tool stores gocryptfs paths,
corresponding mount points as well as passwords in the GNOME keyring and
optionally mounts gocryptfs paths automatically on login to a GNOME session (works
only if gnome-gocryptfs is installed in the system path, at /usr/bin or
/usr/local/bin).
"""

VERSION="0.1"

# bitwise or'able return codes
RC_OK = 0
RC_MOUNT_FAILED = 1
RC_KEYRING_LOCKED = 2
RC_UNKNOWN_ITEM = 4
RC_INVALID_PATH = 8
RC_MOUNT_POINT_IN_USE = 16

# =============================================================================
# helper
# =============================================================================

def _options():
    """Parse command line options."""

    op = optparse.OptionParser(usage=USAGE, version=VERSION,
                               description=DESCRIPTION, epilog=EPILOG)

    op.add_option("-l", "--list", action="store_true", default=False,
                  help="list all gocryptfs items stored in keyring")
    op.add_option("-m", "--mount", action="store_true", default=False,
                  help="mount all or selected gocryptfs paths stored in keyring")
    op.add_option("-a", "--add", action="store_true", default=False,
                  help="add a new gocryptfs item to keyring")
    op.add_option("-e", "--edit", action="store_true", default=False,
                  help="edit an gocryptfs item in keyring")
    op.add_option("-r", "--remove", action="store_true", default=False,
                  help="remove an gocryptfs item from keyring")

    og = optparse.OptionGroup(op, "Non-interactive")
    og.add_option("", "--proceed", default=None,
                  help="Input for proceed question")
    og.add_option("", "--password", default=None, metavar="PW",
                  help="Input for password prompt")
    og.add_option("", "--epath", default=None,
                  help="Input for gocryptfs path edit")
    og.add_option("", "--mpoint", default=None,
                  help="Input for mount point edit")
    og.add_option("", "--amount", default=None,
                  help="Input for auto mount question")
    og.add_option("", "--econfig", default=None,
                  help="Input for gocryptfs config file question")

    op.add_option_group(og)

    opts, args = op.parse_args()

    try:
        args.remove("autostart")
        opts.autostart = True
        opts.mount = True
    except ValueError:
        opts.autostart = False

    if opts.list + opts.mount + opts.add + opts.edit + opts.remove != 1:
        op.print_help()
        op.exit(1)

    # normalize paths
    args = [_pathify(a) for a in args]

    opts.p1 = args and args.pop(0) or None
    opts.p2 = args and args.pop(0) or None

    if opts.add and not (opts.p1 and opts.p2):
        op.error("add needs an gocryptfs path and a moint point")
        op.print_help()
        op.exit(1)

    if opts.remove and not opts.p1:
        op.error("remove needs a moint point")
        op.print_help()
        op.exit(1)

    preset.proceed = opts.proceed
    preset.password = opts.password
    preset.epath = opts.epath
    preset.mpoint = opts.mpoint
    preset.amount = opts.amount
    preset.econfig = opts.econfig

    return opts

def _exit(rc):
    """Exit with additional check if autostart file is still needed."""

    if rc != RC_KEYRING_LOCKED: # getting items requires an unlocked keyring
        _autostart(KEYRING.find({'auto-mount': 'y'}))
    sys.exit(rc)

def _proceed(msg):
    print("Warning: %s" % msg)
    proceed = preset.proceed or raw_input("Proceed [y/N]: ") or "n"
    if proceed.strip()[0].lower() != "y":
        _exit(2)

def _pathify(path):

    path = os.path.expanduser(path)
    path = os.path.expandvars(path)
    path = os.path.abspath(path)
    path = os.path.realpath(path)
    return path

def _config_commands(config):
    """Returns a list of additional commands needed to handle the
    configuration. If the config is '-' then it returns an empty list.

    :param config: String path to config file or '-'
    """
    if config != '-' and os.path.exists(config):
        return ["-config", config]
    else:
        return []

def _is_mounted(mpoint):
    """Check of something is mounted at given mount point."""

    p = subprocess.Popen(["mount"], stdout=subprocess.PIPE)
    mount = p.communicate()[0]
    lines = mount.strip('\n').split('\n')
    points = map(lambda line: line.split()[2], lines)
    points = [os.path.abspath(p) for p in points]
    return os.path.abspath(mpoint) in points

def _is_gocryptfs(epath, econfig):
    """Check if 'epath' points to an gocryptfs directory."""

    command = ["gocryptfs", "-info", epath]
    command.extend(_config_commands(econfig))

    p = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
    )
    p.communicate()
    return p.returncode == 0

def _autostart(enable):
    """Set up XDG autostart file."""

    if TEST:
        fname = os.path.join(os.path.curdir, "autostart.desktop")
    else:
        fname = os.path.join(xdg_ch, "autostart", "gnome-gocryptfs.desktop")

    if not enable:
        if os.path.exists(fname):
            os.remove(fname)
        return

    content = {
        "Exec": "gnome-gocryptfs autostart",
        "Name": "Mount gocryptfs",
        "Comment": "Mount gocryptfs folders configured in GNOME's keyring",
        "Icon": "folder",
        "Version": "1.0",
        "X-GNOME-Autostart-enabled": "true"
    }

    de = xdg_de(filename=fname)
    for key, value in content.items():
        de.set(key, value)
    de.validate()
    de.write()

# =============================================================================
# actions
# =============================================================================


def list_items(path=None):
    """List gocryptfs items in keyring.

    :param path: String path of the mount point
    """

    if path is not None:
        items = KEYRING.find_keys_for_path(path)
    else:
        items = KEYRING.find()

    if not items and path:
        print(MSG_NO_MATCH)
        return RC_UNKNOWN_ITEM

    for item in items:
        attributes = item.get_attributes()
        attributes['auto-mount'] = 'yes' if attributes['auto-mount'] == 'y' else 'no'

        message =  "* gocryptfs path   : {gocryptfs-path}\n"
        message += "  mount point      : {mount-point}\n"
        message += "  mount at login   : {auto-mount}\n"
        message += "  gocryptfs config : {gocryptfs-config}"

        #print(message.format_map(attributes))
        print(message.format(**attributes))

    return RC_OK

def add_item(epath, mpoint):
    """Add new gocryptfs item to keyring.

    :param epath: Encrypted directory path
    :param mpath: Mount point path
    """

    if not os.path.isdir(mpoint):
        _proceed("mount point is not a directory")
    if KEYRING.find({'mount-point': mpoint}):
        _proceed("mount point already in keyring")

    econfig = preset.econfig or raw_input("gocryptfs config file [-]: ") or "-"

    if not _is_gocryptfs(epath, econfig):
        _proceed(MSG_NO_GOCRYPTFS_PATH)

    secret = preset.password or getpass.getpass("gocryptfs password: ")
    amount = preset.amount or raw_input("Mount at login [Y/n]: ") or "y"
    amount = amount.strip()[0].lower() == "y" and "y" or "n"

    attributes = KEYRING.default_attributes()
    attributes.update({
        "gocryptfs-path": epath,
        "mount-point": mpoint,
        "auto-mount": amount,
        "gocryptfs-config": econfig,
    })

    label = "gocryptfs mount at %s" % mpoint
    KEYRING.add(label, attributes, secret)

    return RC_OK

def edit_item(mpoint):
    """Edit gocryptfs item in keyring.

    :param mpoint: Mount point path
    """
    # Find all matching endpoints
    edits = KEYRING.find({'mount-point': mpoint})

    if not edits:
        print(MSG_NO_MATCH)
        return RC_UNKNOWN_ITEM

    # Map the existing mount points to their object IDs
    items = KEYRING.find()
    mount_point_to_ids = defaultdict(set)
    for item in items:
        attributes = item.get_attributes()
        mount_point_to_ids[attributes["mount-point"]].add(id(item))

    for item in edits:

        # get item data
        attributes = item.get_attributes()
        attributes["gocryptfs-path"] = _pathify(
            preset.epath or
            raw_input("gocryptfs path [%s]: " % attributes["gocryptfs-path"]) or
            attributes["gocryptfs-path"]
        )
        attributes["gocryptfs-config"] = (
            preset.econfig or
            raw_input("gocryptfs config file [%s] (`-`: default): " % attributes["gocryptfs-config"]) or
            attributes["gocryptfs-config"]
        )
        attributes["mount-point"] = _pathify(
            preset.mpoint or
            raw_input("Mount point [%s]: " % attributes["mount-point"]) or
            attributes["mount-point"]
        )
        secret = (
            preset.password or
            getpass.getpass("Password [**current**]: ") or
            None
        )
        attributes["auto-mount"] = (
            preset.amount or
            raw_input("Mount at login [%s]: " % "Y/n" if attributes["auto-mount"] == "y" else "y/N") or
            attributes["auto-mount"]
        )
        attributes["auto-mount"] = (
            "y" if attributes["auto-mount"].strip()[0].lower() == "y" else "n"

        )

        # check item data
        has_conflicting_mount_point = (
            attributes["mount-point"] in mount_point_to_ids and
            id(item) not in mount_point_to_ids[attributes["mount-point"]]
        )
        if has_conflicting_mount_point:
            _proceed("mount point already in use")
        if not _is_gocryptfs(attributes["gocryptfs-path"], attributes["gocryptfs-config"]):
            _proceed(MSG_NO_GOCRYPTFS_PATH)
        if not os.path.isdir(mpoint):
            _proceed("mount point is not a directory")

        # update item data
        KEYRING.edit(item, attributes=attributes, secret=secret)

    return RC_OK

def remove_item(mpoint):
    """Remove gocryptfs item from keyring."""

    items = KEYRING.find({'mount-point': mpoint})

    if not items:
        print(MSG_NO_MATCH)
        return RC_UNKNOWN_ITEM

    for item in items:
        KEYRING.remove(item)

    return RC_OK

def mount_items(path, autostart):
    """Mount selected items.

    If `path` is set, mount only those items where the gocryptfs path or mount
    point equals `path`. If `autostart` is True, mount only those items where
    auto-mount is set to 'y'.

    Return true if all items have been mounted successfully and false
    otherwise.

    """

    attributes = {'auto-mount': 'y'} if autostart else {}

    if path is None:
        items = KEYRING.find(attributes)
    else:
        items = KEYRING.find_keys_for_path(path, attributes)

    if not items and path:
        print(MSG_NO_MATCH)
        return RC_UNKNOWN_ITEM

    rc = 0

    for item in items:
        attributes = item.get_attributes()

        #msg = "Mounting {gocryptfs-path} at {mount-point}: ".format_map(attributes)
        msg = "Mounting {gocryptfs-path} at {mount-point}: ".format(**attributes)

        if _is_mounted(attributes["mount-point"]):
            msg += "mount point already in use"
            rc |= RC_MOUNT_POINT_IN_USE
        elif not os.path.isdir(attributes["mount-point"]):
            msg += "mount point does not exist or is not a directory"
            rc |= RC_INVALID_PATH
        else:
            command = [
                "gocryptfs",
                "-o",
                "nonempty",
                attributes["gocryptfs-path"],
                attributes["mount-point"]
            ]
            command.extend(_config_commands(attributes["gocryptfs-config"]))

            p = subprocess.Popen(command, stdin=subprocess.PIPE)
            p.communicate(input="%s\n" % item.get_secret().get().decode())
            msg += p.returncode and "FAILED" or "OK"
            rc |= 0 if p.returncode == os.EX_OK else RC_MOUNT_FAILED

        print(msg)

    return rc

# =============================================================================
# main
# =============================================================================

def main():

    opts = _options()

    if opts.add:
        rc = add_item(opts.p1, opts.p2)
    elif opts.list:
        rc = list_items(opts.p1)
    elif opts.mount:
        rc = mount_items(opts.p1, opts.autostart)
    elif opts.edit:
        rc = edit_item(opts.p1)
    elif opts.remove:
        rc = remove_item(opts.p1)
    else:
        assert False

    return rc

if __name__ == '__main__':
    rc = main()
    # TODO: Determine exception for a locked keyring
    #except gk.CancelledError:
    #    rc = RC_KEYRING_LOCKED
    _exit(rc)
